Одним из больших недостатков функционального программирования является то, что на теоретическом уровне оно
не соответствует аппаратному обеспечению, а также большинству императивных языков.
Например, функциональное программирование широко использует рекурсию. Это прекрасно в чистом исчислении lambda,
потому что математика "stack" безгранична. Конечно, на реальном оборудовании стек очень конечен. Наивная рекурсия
по большому набору данных может привести к тому, что ваша программа взорвется. Большинство функциональных языков
оптимизируют хвостовую рекурсию, чтобы этого не произошло, но создание хвостовой рекурсии алгоритма может заставить
вас сделать довольно некрасивую гимнастику кода (например, функция хвостовой рекурсии карты создает обратный список
или должна создать список различий, поэтому ей приходится выполнять дополнительную работу, чтобы вернуться к
нормальному отображенному списку в правильном порядке по сравнению с версией non-tail-recursive).

Недостатки ООП
Неэффективность на этапе выполнения. В языках типа Smalltalk сообщения интерпретируются во время выполнения
программы путем осуществления их поиска в одной или нескольких таблицах и за счет выбора подходящего метода.
Конечно, это медленный процесс. И даже при использовании наилучших методов оптимизации Smalltalk-программы в десять
раз медленнее оптимизированных C-программ.
В гибридных языках типа Oberon-2, Object Pascal и C++ отправка сообщения приводит лишь к вызову через указатель
процедурной переменной. На некоторых машинах сообщения выполняются лишь на 10% медленнее, чем обычные процедурные
вызовы. И поскольку сообщения встречаются в программе гораздо реже других операций, их воздействие на время
выполнения влияния практически не оказывает.
Однако существует другой фактор, который влияет на время выполнения: это инкапсуляция данных. Рекомендуется
не предоставлять прямой доступ к полям класса, а выполнять каждую операцию над данными через методы. Такая схема
приводит к необходимости выполнения процедурного вызова каждый раз при доступе к данным. Однако если инкапсуляция
используется только там, где она необходима (т.е. в тех случаях, когда это становится преимуществом), то замедление
вполне приемлемое.
Неэффективность в смысле распределения памяти. Динамическое связывание и проверка типа на этапе выполнения требуют
по ходу работы информацию о типе объекта. Такая информация хранится в дескрипторе типа и он выделяется один на
класс. Каждый объект имеет невидимый указатель на дескриптор типа для своего класса. Таким образом, в
объектно-ориентированных программах необходимая дополнительная память выражается в одном указателе для объекта и в
одном дескрипторе типа для класса.
Излишняя универсальность. Неэффективность также может означать, что в программе реализованы избыточные возможности.
В библиотечном классе часто содержится больше методов, чем это реально необходимо. А поскольку лишние методы
не могут быть удалены, они становятся мертвым грузом. Это не влияет на время выполнения, но сказывается на размере
кода.
Одно из возможных решений - строить базовый класс с минимальным числом методов, а затем уже реализовывать различные
расширения этого класса, которые позволят нарастить функциональность. Другой подход - дать компоновщику возможность
удалять лишние методы. Такие интеллектуальные компоновщики уже существуют для различных языков и операционных
систем.
